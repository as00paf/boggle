'use strict';

Object.defineProperty(exports, "__esModule", {
  value: true
});

var _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"]) _i["return"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError("Invalid attempt to destructure non-iterable instance"); } }; }();

exports.default = initSolver;

var _config = require('./config');

var _config2 = _interopRequireDefault(_config);

var _findAdjacents = require('./findAdjacents');

var _findAdjacents2 = _interopRequireDefault(_findAdjacents);

var _utils = require('./utils');

var _utils2 = _interopRequireDefault(_utils);

var _triePrefixTree = require('trie-prefix-tree');

var _triePrefixTree2 = _interopRequireDefault(_triePrefixTree);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MIN_WORD_LEN = _config2.default.minWordLen;

function initSolver(boggle, boggleSize, trie, minWordLen) {
  // allow the user to customise the minimum word length returned
  // the default is 3
  minWordLen = minWordLen || MIN_WORD_LEN;

  // create the matrix
  var boggleMatrix = _utils2.default.getBoggleMatrix(boggleSize, boggle);

  // create the full object that will contain
  // a word and corresponding co-ordinates
  var full = [];
  var list = [];

  // recursive solve algorithm
  var solve = function solve(word, position) {
    var deepCoords = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];
    var deepUsed = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];

    var _position = _slicedToArray(position, 2),
        row = _position[0],
        col = _position[1];

    var wordLen = word.length;

    // create new copies of both coords and used positions
    // for each letter
    var coords = deepCoords.slice();
    var used = deepUsed.slice();

    // push the current position into the co-ordinates array
    coords.push(position);

    // check if the current word is valid
    if (wordLen >= minWordLen) {
      var isValid = trie.hasWord(word);
      var isFound = list.indexOf(word) !== -1;

      if (isValid && !isFound) {
        full.push({ word: word, coords: coords });
        list.push(word);

        // reset co-ordinates ready for the next word
        deepCoords = [];
      }
    }

    // find adjacent letters in the matrix
    var adjacents = (0, _findAdjacents2.default)(position, boggleSize, deepUsed);

    // filter adjacents that are not valid prefixes
    var validAdjacents = adjacents.filter(function (adjacent) {
      var _adjacent = _slicedToArray(adjacent, 2),
          x = _adjacent[0],
          y = _adjacent[1];

      var isPrefix = trie.isPrefix(word + boggleMatrix[x][y]);

      return isPrefix;
    });

    validAdjacents.forEach(function (adjacent) {
      used.push(position);

      var _adjacent2 = _slicedToArray(adjacent, 2),
          x = _adjacent2[0],
          y = _adjacent2[1];

      var letter = boggleMatrix[x][y];
      var currentWord = word + letter;

      solve(currentWord, adjacent, coords, used);
    });
  };

  // solve each letter in turn
  boggleMatrix.forEach(function (row, rowIndex) {
    row.forEach(function (col, colIndex) {
      solve(boggleMatrix[rowIndex][colIndex], [rowIndex, colIndex]);
    });
  });

  // create a trie from the resulting word list
  var resultTrie = (0, _triePrefixTree2.default)(list);

  return {
    full: full,
    list: list,
    hasWord: function hasWord(word) {
      return resultTrie.hasWord(word);
    },
    contains: function contains(letters) {
      var arr = Array.from(letters);
      return list.filter(function (word) {
        return arr.every(function (letter) {
          return word.indexOf(letter) !== -1;
        });
      });
    },
    startsWith: function startsWith(prefix) {
      return resultTrie.getPrefix(prefix);
    },
    endsWith: function endsWith(suffix) {
      return list.filter(function (word) {
        var wordLen = word.length;
        var startAt = wordLen - suffix.length;
        return word.substring(startAt, wordLen) === suffix.toLowerCase();
      });
    },
    lengthOf: function lengthOf(length) {
      return list.filter(function (word) {
        return word.length === length;
      });
    }
  };
};
module.exports = exports['default'];